# VUE常见面试题

#### Vue的基本原理

Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty将他们转为getter/setter，在内部追踪相关依赖，属性被访问和修改时通知变化，每个组件实例都有相应的watcher程序实例，会在组件渲染的过程中把属性记录为依赖，当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新



#### 双向数据绑定原理:question:

**Vue采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调**

1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
2. compile解析横板令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个令对象的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. Watcher订阅名是observer和Compile之间通信的桥梁，主要做的事情是
   1. 在自身实例化时往属性订阅器(dep)里面添加自己
   2. 自身必须有一个update方法
   3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中定的回调
4. MVVM作为数据绑定的入口，合observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新：视图交互变化（input）-> 数据mode变更的双向绑定效果







#### Object.defineProperty数据劫持的缺点

对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，都不能触发组件的重新渲染，对于数组而言，大部分操作都无法拦截，知识Vue内部对此进行重写了

Vue3.x使用Proxy对对象进行代理，可以完美监听到任何方式的数据改变，缺点时兼容性问题，Proxy属性ES6



#### Computed和watch区别

Computed

* 支持缓存，只有依赖的数据发生了变化才重新计算
* 不支持异步，若有异步操作，无法监听数据变化
* computed的值默认走缓存，计算属性是基于响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的
* 如果一个属性是由其他属性计算而来，这个属性依赖其他属性，会使用computed
* 如果computed属性的属性值是函数，那么默认使用get方法，函数返回值就是属性的属性值，在computed中，属性有一个get和set方法，数据发生变化时，会调用set方法

Watch

* 不支持缓存，数据变化就会触发相应操作
* 支持异步监听
* 监听函数接受两个参数，一个是最新的值，第二个是变化之前的值
* 当一个属性发生变化时，需要执行相应的操作
* 监听数据必须是data中声明的或者父组件传递过来的props中的数据，发生变化时，会触发其他操作，函数有两个参数
  * immediate: 组件加载立即触发回调函数
  * deep 深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化，deep无法监听到数组和对象内部的变化

当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch

总结：

* computed计算属性：依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值才会重新计算computed的值
* watch侦听器：更多的时观察的作用，无缓存行，类似于某些数据的监听回调，每当监听的数据变化都会执行回调

#### data为什么是一个函数而非对象

JS中对象时引用类型的数据，当多个实例引用同一个对象，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化

Vue中更多的是复用组件，每个组件都要用自己单独的数据



#### keep-alive实现

1. 获取keep-alive下第一个子组件的实例对象，通过它去获取这个组件的组件名
2. 通过当前组件名去匹配原来include和exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode
3. 需要缓存，判断他当前是否在缓存数组里面
   1. 存在，将原来位置上的key移除，同时将这个组件的key放到数组最后
   2. 不存在，将组件key放入数组，然后判断key数组是否超过max所设置的范围，超过，那么削减未使用时间最长的一个组件的key
4. 最后将这个组件的keep-alive设置为true

#### nextTick原理

Vue的nextTick其本质是对Javascript执行原理EventLoop的一种应用

nextTick核心是利用了如Promise、MutationObserver、setImmediate、setTimeout的原生JS方法来模拟对象的微/宏任务的实现，本质是为了利用JS的这些异步回调任务队列来实现Vue框架中自己的异步回调队列



#### 首屏加载时间















